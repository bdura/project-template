{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview This repository proposes a template for Python projects. Features : Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy I basically used the best practice from EDS-PDF 1 , although I updated a few parts. Basile Dura, Perceval Wajsburt, Alice Calliger, Christel G\u00e9rardin, and Romain Bey. EDS-PDF: Smart text extraction from PDF documents. URL: https://github.com/aphp/edspdf , doi:10.5281/zenodo.6902977 . \u21a9","title":"Overview"},{"location":"#overview","text":"This repository proposes a template for Python projects. Features : Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy I basically used the best practice from EDS-PDF 1 , although I updated a few parts. Basile Dura, Perceval Wajsburt, Alice Calliger, Christel G\u00e9rardin, and Romain Bey. EDS-PDF: Smart text extraction from PDF documents. URL: https://github.com/aphp/edspdf , doi:10.5281/zenodo.6902977 . \u21a9","title":"Overview"},{"location":"changelog/","text":"Changelog v0.1.0 (2023-02-12) Inception ! Features Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v010-2023-02-12","text":"Inception !","title":"v0.1.0 (2023-02-12)"},{"location":"changelog/#features","text":"Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy","title":"Features"},{"location":"reading-list/","text":"Reading List Python types intro","title":"Reading List"},{"location":"reading-list/#reading-list","text":"Python types intro","title":"Reading List"},{"location":"roadmap/","text":"Roadmap","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"environment/","text":"Coding environment To code efficiently, you'll need a good coding environment. This section proposes a set of tools that should make your life much easier. By the way, you should really learn Markdown .","title":"Coding environment"},{"location":"environment/#coding-environment","text":"To code efficiently, you'll need a good coding environment. This section proposes a set of tools that should make your life much easier. By the way, you should really learn Markdown .","title":"Coding environment"},{"location":"environment/git/","text":"Using and configuring Git Skip if you're familiar This is rather basic stuff. If you know all about Git and SSH keys, you should definitely skip this section. Git is an ubiquitous versioning tool that was created by Linus Tovalds, the creator of the Linux operating system. With git, you can version your code, meaning that you can take \"pictures\" of your code and modify it incrementally. Git is also design to help you collaborate. If this is too abstract, which it probably is, read the Primer below. Git Primer If you're absolutely new to Git, find a tutorial and come back to this page. This might be a good way to start (I haven't done it myself). Using an SSH key Security concerns You should use SSH keys whenever possible, to avoid compromising your password. If your SSH key is compromised, you can invalidate it and create a new one.","title":"Using and configuring Git"},{"location":"environment/git/#using-and-configuring-git","text":"Skip if you're familiar This is rather basic stuff. If you know all about Git and SSH keys, you should definitely skip this section. Git is an ubiquitous versioning tool that was created by Linus Tovalds, the creator of the Linux operating system. With git, you can version your code, meaning that you can take \"pictures\" of your code and modify it incrementally. Git is also design to help you collaborate. If this is too abstract, which it probably is, read the Primer below.","title":"Using and configuring Git"},{"location":"environment/git/#git-primer","text":"If you're absolutely new to Git, find a tutorial and come back to this page. This might be a good way to start (I haven't done it myself).","title":"Git Primer"},{"location":"environment/git/#using-an-ssh-key","text":"Security concerns You should use SSH keys whenever possible, to avoid compromising your password. If your SSH key is compromised, you can invalidate it and create a new one.","title":"Using an SSH key"},{"location":"environment/ide/","text":"Integrated Development Environment A good Integrated Development Environment (IDE) is important. I've used two: PyCharm and VS Code, both great options. I would advise to use VS Code . It is lightweight, fast, ships with a load of incredible goodies and has an extension for about everything. Make sure to activate auto-saving. Go to Settings and search for auto save and select afterDelay . Extensions Installing extensions To install an extension in VS Code, just go to to the extensions panel (should be the last button on the left of your VS Code window), search for an extension, and click \"Install\". See the official instructions . A few extensions that will help you code faster than ever: Pylance and Python : a language server for Python Prettier : a great code formatter Jupyter : Jupyter support within VS Code Gitlens : Git supercharged Auto docstrings : automatically generate docstrings. Coverage Gutters : display test coverage YAML : YAML syntax highlighting Better TOML : TOML syntax highlighting SQLTools : explore an SQL database from VS Code Thunder Client : test REST API from VS Code Todo Tree : highlight todos and checklists Conventional commits : help you use conventional commits Markdown all in one : supercharge your markdown editor Markdown PDF : save your markdowns to PDF Marp for VS Code : create stunning presentations in markdown When coding in Python, make sure to activate auto-saving, formatting on save with Black, and type checking with mypy.","title":"IDE"},{"location":"environment/ide/#integrated-development-environment","text":"A good Integrated Development Environment (IDE) is important. I've used two: PyCharm and VS Code, both great options. I would advise to use VS Code . It is lightweight, fast, ships with a load of incredible goodies and has an extension for about everything. Make sure to activate auto-saving. Go to Settings and search for auto save and select afterDelay .","title":"Integrated Development Environment"},{"location":"environment/ide/#extensions","text":"Installing extensions To install an extension in VS Code, just go to to the extensions panel (should be the last button on the left of your VS Code window), search for an extension, and click \"Install\". See the official instructions . A few extensions that will help you code faster than ever: Pylance and Python : a language server for Python Prettier : a great code formatter Jupyter : Jupyter support within VS Code Gitlens : Git supercharged Auto docstrings : automatically generate docstrings. Coverage Gutters : display test coverage YAML : YAML syntax highlighting Better TOML : TOML syntax highlighting SQLTools : explore an SQL database from VS Code Thunder Client : test REST API from VS Code Todo Tree : highlight todos and checklists Conventional commits : help you use conventional commits Markdown all in one : supercharge your markdown editor Markdown PDF : save your markdowns to PDF Marp for VS Code : create stunning presentations in markdown When coding in Python, make sure to activate auto-saving, formatting on save with Black, and type checking with mypy.","title":"Extensions"},{"location":"environment/zsh/","text":"Using a Decent Shell Most distributions come with the Bourne Again Shell (bash). You can do better by using Zsh, an alternative to Bash that provides a myriad of bonuses. Primer on the Command Line If this your first time using the command line, you should probably read this primer by Ubuntu. Although the tutorial is designed for Ubuntu users, you can follow along with any Linux or Mac computer. On PC, you'll need the Windows Subsystem for Linux . I have never done this since I do not own a PC, but I know this is a popular set up among developers using PC. Zsh Installation Follow the instructions . Install oh-my-zsh oh-my-zsh is a package manager for Zsh. It can help you customize your shell with incredibly useful perks. Follow the instructions . Install spaceship-prompt There are other prompts out there, but Spaceship is a good way to start. Follow the instructions . Configuring your shell The following .zshrc should be a good place to start. ~/.zshrc # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH = \" $HOME /.oh-my-zsh\" # Set name of the theme to load --- if set to \"random\", it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME = \"spaceship\" SPACESHIP_USER_SHOW = \"always\" SPACESHIP_CHAR_SYMBOL = \" \u279c \" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\"true\" # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\"true\" # Uncomment the following line to disable bi-weekly auto-update checks. # DISABLE_AUTO_UPDATE=\"true\" # Uncomment the following line to automatically update without prompting. # DISABLE_UPDATE_PROMPT=\"true\" # Uncomment the following line to change how often to auto-update (in days). # export UPDATE_ZSH_DAYS=13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\"true\" # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\"true\" # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\"true\" # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\"true\" # Uncomment the following line to display red dots whilst waiting for completion. # Caution: this setting can cause issues with multiline prompts (zsh 5.7.1 and newer seem to work) # See https://github.com/ohmyzsh/ohmyzsh/issues/5765 # COMPLETION_WAITING_DOTS=\"true\" # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\"true\" # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\" # or set a custom format using the strftime function format specifications, # see 'man strftime' for details. # HIST_STAMPS=\"mm/dd/yyyy\" # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins =( git zsh-syntax-highlighting ) source $ZSH /oh-my-zsh.sh # User configuration export PATH = \" $HOME /.local/bin: $PATH \" # export MANPATH=\"/usr/local/man:$MANPATH\" # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR='vim' # else # export EDITOR='mvim' # fi # Compilation flags # export ARCHFLAGS=\"-arch x86_64\" # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # Example aliases alias zshconfig = \"micro ~/.zshrc\" alias ohmyzsh = \"micro ~/.oh-my-zsh\" Next, you should install Powerlevel10k. But spaceship is a good place to start.","title":"Using a Decent Shell"},{"location":"environment/zsh/#using-a-decent-shell","text":"Most distributions come with the Bourne Again Shell (bash). You can do better by using Zsh, an alternative to Bash that provides a myriad of bonuses.","title":"Using a Decent Shell"},{"location":"environment/zsh/#primer-on-the-command-line","text":"If this your first time using the command line, you should probably read this primer by Ubuntu. Although the tutorial is designed for Ubuntu users, you can follow along with any Linux or Mac computer. On PC, you'll need the Windows Subsystem for Linux . I have never done this since I do not own a PC, but I know this is a popular set up among developers using PC.","title":"Primer on the Command Line"},{"location":"environment/zsh/#zsh","text":"","title":"Zsh"},{"location":"environment/zsh/#installation","text":"Follow the instructions .","title":"Installation"},{"location":"environment/zsh/#install-oh-my-zsh","text":"oh-my-zsh is a package manager for Zsh. It can help you customize your shell with incredibly useful perks. Follow the instructions .","title":"Install oh-my-zsh"},{"location":"environment/zsh/#install-spaceship-prompt","text":"There are other prompts out there, but Spaceship is a good way to start. Follow the instructions .","title":"Install spaceship-prompt"},{"location":"environment/zsh/#configuring-your-shell","text":"The following .zshrc should be a good place to start. ~/.zshrc # If you come from bash you might have to change your $PATH. # export PATH=$HOME/bin:/usr/local/bin:$PATH # Path to your oh-my-zsh installation. export ZSH = \" $HOME /.oh-my-zsh\" # Set name of the theme to load --- if set to \"random\", it will # load a random theme each time oh-my-zsh is loaded, in which case, # to know which specific one was loaded, run: echo $RANDOM_THEME # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes ZSH_THEME = \"spaceship\" SPACESHIP_USER_SHOW = \"always\" SPACESHIP_CHAR_SYMBOL = \" \u279c \" # Set list of themes to pick from when loading at random # Setting this variable when ZSH_THEME=random will cause zsh to load # a theme from this variable instead of looking in $ZSH/themes/ # If set to an empty array, this variable will have no effect. # ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" ) # Uncomment the following line to use case-sensitive completion. # CASE_SENSITIVE=\"true\" # Uncomment the following line to use hyphen-insensitive completion. # Case-sensitive completion must be off. _ and - will be interchangeable. # HYPHEN_INSENSITIVE=\"true\" # Uncomment the following line to disable bi-weekly auto-update checks. # DISABLE_AUTO_UPDATE=\"true\" # Uncomment the following line to automatically update without prompting. # DISABLE_UPDATE_PROMPT=\"true\" # Uncomment the following line to change how often to auto-update (in days). # export UPDATE_ZSH_DAYS=13 # Uncomment the following line if pasting URLs and other text is messed up. # DISABLE_MAGIC_FUNCTIONS=\"true\" # Uncomment the following line to disable colors in ls. # DISABLE_LS_COLORS=\"true\" # Uncomment the following line to disable auto-setting terminal title. # DISABLE_AUTO_TITLE=\"true\" # Uncomment the following line to enable command auto-correction. # ENABLE_CORRECTION=\"true\" # Uncomment the following line to display red dots whilst waiting for completion. # Caution: this setting can cause issues with multiline prompts (zsh 5.7.1 and newer seem to work) # See https://github.com/ohmyzsh/ohmyzsh/issues/5765 # COMPLETION_WAITING_DOTS=\"true\" # Uncomment the following line if you want to disable marking untracked files # under VCS as dirty. This makes repository status check for large repositories # much, much faster. # DISABLE_UNTRACKED_FILES_DIRTY=\"true\" # Uncomment the following line if you want to change the command execution time # stamp shown in the history command output. # You can set one of the optional three formats: # \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\" # or set a custom format using the strftime function format specifications, # see 'man strftime' for details. # HIST_STAMPS=\"mm/dd/yyyy\" # Would you like to use another custom folder than $ZSH/custom? # ZSH_CUSTOM=/path/to/new-custom-folder # Which plugins would you like to load? # Standard plugins can be found in $ZSH/plugins/ # Custom plugins may be added to $ZSH_CUSTOM/plugins/ # Example format: plugins=(rails git textmate ruby lighthouse) # Add wisely, as too many plugins slow down shell startup. plugins =( git zsh-syntax-highlighting ) source $ZSH /oh-my-zsh.sh # User configuration export PATH = \" $HOME /.local/bin: $PATH \" # export MANPATH=\"/usr/local/man:$MANPATH\" # You may need to manually set your language environment # export LANG=en_US.UTF-8 # Preferred editor for local and remote sessions # if [[ -n $SSH_CONNECTION ]]; then # export EDITOR='vim' # else # export EDITOR='mvim' # fi # Compilation flags # export ARCHFLAGS=\"-arch x86_64\" # Set personal aliases, overriding those provided by oh-my-zsh libs, # plugins, and themes. Aliases can be placed here, though oh-my-zsh # users are encouraged to define aliases within the ZSH_CUSTOM folder. # For a full list of active aliases, run `alias`. # Example aliases alias zshconfig = \"micro ~/.zshrc\" alias ohmyzsh = \"micro ~/.oh-my-zsh\" Next, you should install Powerlevel10k. But spaceship is a good place to start.","title":"Configuring your shell"},{"location":"howto/","text":"How To Overview This is a section index...","title":"How To Overview"},{"location":"howto/#how-to-overview","text":"This is a section index...","title":"How To Overview"},{"location":"howto/dependency-management/","text":"Dependency Management with Poetry Poetry is a strict dependency management tool that makes sure your Python environment is fully reproducible. To that end, Poetry keeps track of all dependencies (meaning the requirements you specify, as well as their requirements, recursively) and saves the state of your environment into a poetry.lock file. This is standard practice For instance, in JavaScript, the packager Yarn keeps a yarn.lock file for the exact same purpose. Poetry is configured within a pyproject.toml file, where (potentially lax) constraints are placed on your requirements. When you install for the first time, Poetry will: Make sure the constraints can be resolved (eg you specify pandas>1.2 and some-library , which specifies pandas<1.1.4 internally) Install the most up-to-date relevant version for every dependency. Then, you can update your environment with poetry update . Poetry will again install the most up-to-date relevant version for every dependency. See Poetry's refresher course on semantic versionning if need be. Installing a new dependency Poetry introduces the concept of dependency group . Your project may require a library to run, or for development purposes (eg formatter, linter, tests). It's best practice to divide theses into groups. Let's say your project needs Pandas to run, and Pytest for testing. One way to install those would be: color:grey # Add pandas to the default group $ poetry add pandas ---> 100% color:grey # Add pytest to the \"test\" group $ poetry add --group test pytest ---> 100% Removing a dependency Call poetry remove [--group] to remove a dependency. $ poetry remove pandas ---> 100%","title":"Dependency Management with Poetry"},{"location":"howto/dependency-management/#dependency-management-with-poetry","text":"Poetry is a strict dependency management tool that makes sure your Python environment is fully reproducible. To that end, Poetry keeps track of all dependencies (meaning the requirements you specify, as well as their requirements, recursively) and saves the state of your environment into a poetry.lock file. This is standard practice For instance, in JavaScript, the packager Yarn keeps a yarn.lock file for the exact same purpose. Poetry is configured within a pyproject.toml file, where (potentially lax) constraints are placed on your requirements. When you install for the first time, Poetry will: Make sure the constraints can be resolved (eg you specify pandas>1.2 and some-library , which specifies pandas<1.1.4 internally) Install the most up-to-date relevant version for every dependency. Then, you can update your environment with poetry update . Poetry will again install the most up-to-date relevant version for every dependency. See Poetry's refresher course on semantic versionning if need be.","title":"Dependency Management with Poetry"},{"location":"howto/dependency-management/#installing-a-new-dependency","text":"Poetry introduces the concept of dependency group . Your project may require a library to run, or for development purposes (eg formatter, linter, tests). It's best practice to divide theses into groups. Let's say your project needs Pandas to run, and Pytest for testing. One way to install those would be: color:grey # Add pandas to the default group $ poetry add pandas ---> 100% color:grey # Add pytest to the \"test\" group $ poetry add --group test pytest ---> 100%","title":"Installing a new dependency"},{"location":"howto/dependency-management/#removing-a-dependency","text":"Call poetry remove [--group] to remove a dependency. $ poetry remove pandas ---> 100%","title":"Removing a dependency"},{"location":"python/","text":"Overview This section deals with a few tips, tricks, and ideas about how to go about writing great code. The \"awesome\" section can be understood as a reading list of interesting packages for Python in general.","title":"Overview"},{"location":"python/#overview","text":"This section deals with a few tips, tricks, and ideas about how to go about writing great code. The \"awesome\" section can be understood as a reading list of interesting packages for Python in general.","title":"Overview"},{"location":"python/awesome/","text":"Awesome Python A curated list of delightful Data Science libraries and resources. For more awesomeness, check out awesome . Reading list Hitchiker's Guide to Python A great resource for Python best practices : idiomatic/ pythonic expressions code structuring common libraries IDE VS Code is a great tool. A few extensions that will help you code faster than ever: Pylance and Python : a language server for Python Jupyter : Jupyter support within VS Code Gitlens : Git supercharged Auto docstrings : automatically generate docstrings. Coverage Gutters : display test coverage YAML : YAML syntax highlighting Better TOML : TOML syntax highlighting SQLTools : explore an SQL database from VS Code Thunder Client : test REST API from VS Code Todo Tree : highlight todos and checklists Conventional commits : help you use conventional commits Markdown all in one : supercharge your markdown editor Markdown PDF : save your markdowns to PDF Marp for VS Code : create stunning presentations in markdown Scripts Typer Type-hint-powered CLI for Python. A must-have. Testing Python code Pytest Pytest is a great library for testing Python code. You really should test your code, and start doing so from day one... You risk letting the workload overrun if you wait too long, testing legacy code is a hassle. With a well defined test-suite, you can refactor your code without having to worry that everything works: you know it does once the tests pass. Hypothesis Hypothesis works with Pytest to automate unit-testing with random examples. Versioning Conventional commits Use conventional commits if you can, it make your git logs much more readable and human (as well as machine) friendly. Semantic Versioning Use semantic versioning for your libraries. Poetry Python dependency management and packaging made easy. Poetry simplifies the dependency management, and makes sure every member of the team is working with the same environment, limiting it works on my machine syndrome. You get a managed virtual environment for free, and packaging becomes easy as a breeze. Logging Loguru A most simple logging library. Removes some of the hassle of using the standard logging library, and goes above and beyond with support for : colored logging exception catching etc. Coding with style Google's style guide Take a look at this great style guide, it goes over many patterns. Black Automatic formatting of your Python files that goes beyond PEP8 compliance. Your code will be neat and tidy, and uniform across your project regardless of the author. In a nutshell : Black reformats your files in place. It is not configurable. Also worth checking out : An incredible Jupyter extension for automatic Black formatting Pre-commit Check and lint you code before committing, to make sure it remains pristine every time! See EDS-NLP's configuration for inspiration. You'll need to install it: # Install with pip pip install pre-commit # Add the pre-commit hook pre-commit install # Run on every files pre-commit run --all-files A great intro to Python types Python types, explained. Documentation MkDocs Write beautiful and modern documentations. See EDS-NLP's documentation and configuration for inspiration.","title":"Awesome Python"},{"location":"python/awesome/#awesome-python","text":"A curated list of delightful Data Science libraries and resources. For more awesomeness, check out awesome .","title":"Awesome Python"},{"location":"python/awesome/#reading-list","text":"","title":"Reading list"},{"location":"python/awesome/#hitchikers-guide-to-python","text":"A great resource for Python best practices : idiomatic/ pythonic expressions code structuring common libraries","title":"Hitchiker's Guide to Python"},{"location":"python/awesome/#ide","text":"VS Code is a great tool. A few extensions that will help you code faster than ever: Pylance and Python : a language server for Python Jupyter : Jupyter support within VS Code Gitlens : Git supercharged Auto docstrings : automatically generate docstrings. Coverage Gutters : display test coverage YAML : YAML syntax highlighting Better TOML : TOML syntax highlighting SQLTools : explore an SQL database from VS Code Thunder Client : test REST API from VS Code Todo Tree : highlight todos and checklists Conventional commits : help you use conventional commits Markdown all in one : supercharge your markdown editor Markdown PDF : save your markdowns to PDF Marp for VS Code : create stunning presentations in markdown","title":"IDE"},{"location":"python/awesome/#scripts","text":"","title":"Scripts"},{"location":"python/awesome/#typer","text":"Type-hint-powered CLI for Python. A must-have.","title":"Typer"},{"location":"python/awesome/#testing-python-code","text":"","title":"Testing Python code"},{"location":"python/awesome/#pytest","text":"Pytest is a great library for testing Python code. You really should test your code, and start doing so from day one... You risk letting the workload overrun if you wait too long, testing legacy code is a hassle. With a well defined test-suite, you can refactor your code without having to worry that everything works: you know it does once the tests pass.","title":"Pytest"},{"location":"python/awesome/#hypothesis","text":"Hypothesis works with Pytest to automate unit-testing with random examples.","title":"Hypothesis"},{"location":"python/awesome/#versioning","text":"","title":"Versioning"},{"location":"python/awesome/#conventional-commits","text":"Use conventional commits if you can, it make your git logs much more readable and human (as well as machine) friendly.","title":"Conventional commits"},{"location":"python/awesome/#semantic-versioning","text":"Use semantic versioning for your libraries.","title":"Semantic Versioning"},{"location":"python/awesome/#poetry","text":"Python dependency management and packaging made easy. Poetry simplifies the dependency management, and makes sure every member of the team is working with the same environment, limiting it works on my machine syndrome. You get a managed virtual environment for free, and packaging becomes easy as a breeze.","title":"Poetry"},{"location":"python/awesome/#logging","text":"","title":"Logging"},{"location":"python/awesome/#loguru","text":"A most simple logging library. Removes some of the hassle of using the standard logging library, and goes above and beyond with support for : colored logging exception catching etc.","title":"Loguru"},{"location":"python/awesome/#coding-with-style","text":"","title":"Coding with style"},{"location":"python/awesome/#googles-style-guide","text":"Take a look at this great style guide, it goes over many patterns.","title":"Google's style guide"},{"location":"python/awesome/#black","text":"Automatic formatting of your Python files that goes beyond PEP8 compliance. Your code will be neat and tidy, and uniform across your project regardless of the author. In a nutshell : Black reformats your files in place. It is not configurable. Also worth checking out : An incredible Jupyter extension for automatic Black formatting","title":"Black"},{"location":"python/awesome/#pre-commit","text":"Check and lint you code before committing, to make sure it remains pristine every time! See EDS-NLP's configuration for inspiration. You'll need to install it: # Install with pip pip install pre-commit # Add the pre-commit hook pre-commit install # Run on every files pre-commit run --all-files","title":"Pre-commit"},{"location":"python/awesome/#a-great-intro-to-python-types","text":"Python types, explained.","title":"A great intro to Python types"},{"location":"python/awesome/#documentation","text":"","title":"Documentation"},{"location":"python/awesome/#mkdocs","text":"Write beautiful and modern documentations. See EDS-NLP's documentation and configuration for inspiration.","title":"MkDocs"},{"location":"python/configuration/","text":"A powerful configuration system Use TOML. It's easy to read yet powerful. It supports comments. One of spaCy's genius moves resides in their configuration system, that uses a format akin to TOML, with the added bonuses of variable interpolation and registry integration.","title":"A powerful configuration system"},{"location":"python/configuration/#a-powerful-configuration-system","text":"Use TOML. It's easy to read yet powerful. It supports comments. One of spaCy's genius moves resides in their configuration system, that uses a format akin to TOML, with the added bonuses of variable interpolation and registry integration.","title":"A powerful configuration system"},{"location":"python/documentation/","text":"Writing Documentation Friends don't let friends write undocumented code. Use mkdocs. It powers this \"documentation\". Setting it up is simple enough : $ mkdocs serve color:green Serving on http://127.0.0.1:8000/","title":"Writing Documentation"},{"location":"python/documentation/#writing-documentation","text":"Friends don't let friends write undocumented code. Use mkdocs. It powers this \"documentation\". Setting it up is simple enough : $ mkdocs serve color:green Serving on http://127.0.0.1:8000/","title":"Writing Documentation"},{"location":"python/reproducibility/","text":"Reproducible Science Reproducibility is one of the keys to making great science. Seeding Poetry DVC Docker","title":"Reproducible Science"},{"location":"python/reproducibility/#reproducible-science","text":"Reproducibility is one of the keys to making great science. Seeding Poetry DVC Docker","title":"Reproducible Science"},{"location":"reference/","text":"template","title":"`template`"},{"location":"reference/#template","text":"","title":"template"},{"location":"reference/SUMMARY/","text":"template functional","title":"SUMMARY"},{"location":"reference/functional/","text":"template.functional add ( a , b ) Add two integers together. PARAMETER DESCRIPTION a Left side of the add. TYPE: int b Right side of the add. TYPE: int RETURNS DESCRIPTION int Result Source code in template/functional.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a : int , b : int ) -> int : \"\"\" Add two integers together. Parameters ---------- a : int Left side of the add. b : int Right side of the add. Returns ------- int Result \"\"\" return a + b","title":"functional"},{"location":"reference/functional/#templatefunctional","text":"","title":"template.functional"},{"location":"reference/functional/#template.functional.add","text":"Add two integers together. PARAMETER DESCRIPTION a Left side of the add. TYPE: int b Right side of the add. TYPE: int RETURNS DESCRIPTION int Result Source code in template/functional.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a : int , b : int ) -> int : \"\"\" Add two integers together. Parameters ---------- a : int Left side of the add. b : int Right side of the add. Returns ------- int Result \"\"\" return a + b","title":"add()"}]}