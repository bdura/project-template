{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview This repository proposes a template for Python projects. Features : Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy I basically used the best practice from EDS-PDF 1 , although I updated a few parts. Basile Dura, Perceval Wajsburt, Alice Calliger, Christel G\u00e9rardin, and Romain Bey. EDS-PDF: Smart text extraction from PDF documents. URL: https://github.com/aphp/edspdf , doi:10.5281/zenodo.6902977 . \u21a9","title":"Overview"},{"location":"#overview","text":"This repository proposes a template for Python projects. Features : Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy I basically used the best practice from EDS-PDF 1 , although I updated a few parts. Basile Dura, Perceval Wajsburt, Alice Calliger, Christel G\u00e9rardin, and Romain Bey. EDS-PDF: Smart text extraction from PDF documents. URL: https://github.com/aphp/edspdf , doi:10.5281/zenodo.6902977 . \u21a9","title":"Overview"},{"location":"changelog/","text":"Changelog v0.1.0 (2023-02-12) Inception ! Features Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v010-2023-02-12","text":"Inception !","title":"v0.1.0 (2023-02-12)"},{"location":"changelog/#features","text":"Strict dependency management with Poetry Beautiful documentation with MkDocs Github actions Testing and coverage using Pytest Consistent formatting with Black Lightning-fast linting with Ruff Static type checking with MyPy","title":"Features"},{"location":"roadmap/","text":"Roadmap","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"howto/","text":"How To Overview This is a section index...","title":"How To Overview"},{"location":"howto/#how-to-overview","text":"This is a section index...","title":"How To Overview"},{"location":"howto/dependency-management/","text":"Dependency Management with Poetry Poetry is a strict dependency management tool that makes sure your Python environment is fully reproducible. To that end, Poetry keeps track of all dependencies (meaning the requirements you specify, as well as their requirements, recursively) and saves the state of your environment into a poetry.lock file. This is standard practice For instance, in JavaScript, the packager Yarn keeps a yarn.lock file for the exact same purpose. Poetry is configured within a pyproject.toml file, where (potentially lax) constraints are placed on your requirements. When you install for the first time, Poetry will: Make sure the constraints can be resolved (eg you specify pandas>1.2 and some-library , which specifies pandas<1.1.4 internally) Install the most up-to-date relevant version for every dependency. Then, you can update your environment with poetry update . Poetry will again install the most up-to-date relevant version for every dependency. See Poetry's refresher course on semantic versionning if need be. Installing a new dependency Poetry introduces the concept of dependency group . Your project may require a library to run, or for development purposes (eg formatter, linter, tests). It's best practice to divide theses into groups. Let's say your project needs Pandas to run, and Pytest for testing. One way to install those would be: color:grey # Add pandas to the default group $ poetry add pandas ---> 100% color:grey # Add pytest to the \"test\" group $ poetry add --group test pytest ---> 100% Removing a dependency Call poetry remove [--group] to remove a dependency. $ poetry remove pandas ---> 100%","title":"Dependency Management with Poetry"},{"location":"howto/dependency-management/#dependency-management-with-poetry","text":"Poetry is a strict dependency management tool that makes sure your Python environment is fully reproducible. To that end, Poetry keeps track of all dependencies (meaning the requirements you specify, as well as their requirements, recursively) and saves the state of your environment into a poetry.lock file. This is standard practice For instance, in JavaScript, the packager Yarn keeps a yarn.lock file for the exact same purpose. Poetry is configured within a pyproject.toml file, where (potentially lax) constraints are placed on your requirements. When you install for the first time, Poetry will: Make sure the constraints can be resolved (eg you specify pandas>1.2 and some-library , which specifies pandas<1.1.4 internally) Install the most up-to-date relevant version for every dependency. Then, you can update your environment with poetry update . Poetry will again install the most up-to-date relevant version for every dependency. See Poetry's refresher course on semantic versionning if need be.","title":"Dependency Management with Poetry"},{"location":"howto/dependency-management/#installing-a-new-dependency","text":"Poetry introduces the concept of dependency group . Your project may require a library to run, or for development purposes (eg formatter, linter, tests). It's best practice to divide theses into groups. Let's say your project needs Pandas to run, and Pytest for testing. One way to install those would be: color:grey # Add pandas to the default group $ poetry add pandas ---> 100% color:grey # Add pytest to the \"test\" group $ poetry add --group test pytest ---> 100%","title":"Installing a new dependency"},{"location":"howto/dependency-management/#removing-a-dependency","text":"Call poetry remove [--group] to remove a dependency. $ poetry remove pandas ---> 100%","title":"Removing a dependency"},{"location":"reference/","text":"template","title":"`template`"},{"location":"reference/#template","text":"","title":"template"},{"location":"reference/SUMMARY/","text":"template functional","title":"SUMMARY"},{"location":"reference/functional/","text":"template.functional add ( a , b ) Add two integers together. PARAMETER DESCRIPTION a Left side of the add. TYPE: int b Right side of the add. TYPE: int RETURNS DESCRIPTION int Result Source code in template/functional.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a : int , b : int ) -> int : \"\"\" Add two integers together. Parameters ---------- a : int Left side of the add. b : int Right side of the add. Returns ------- int Result \"\"\" return a + b","title":"functional"},{"location":"reference/functional/#templatefunctional","text":"","title":"template.functional"},{"location":"reference/functional/#template.functional.add","text":"Add two integers together. PARAMETER DESCRIPTION a Left side of the add. TYPE: int b Right side of the add. TYPE: int RETURNS DESCRIPTION int Result Source code in template/functional.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def add ( a : int , b : int ) -> int : \"\"\" Add two integers together. Parameters ---------- a : int Left side of the add. b : int Right side of the add. Returns ------- int Result \"\"\" return a + b","title":"add()"}]}